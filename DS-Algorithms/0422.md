# 0422

## 그래프(graph)

그래프란 정점(vertax)과 정점들을 연결하는 간선(edge)으로 구성된 비선형 자료구조이다.

<!-- 그래프 이미지 첨부 -->

다음은 그래프의 종류다.

- 무향 그래프: 정점과 정점간 양방향 이동이 가능하다. 간선을 선분으로 표현한다.
- 방향 그래프: 정점과 정점이 단방향으로만 이동할 수 있다. 간선을 화살표로 표현한다.
- 가중 그래프: 간선의 가중치 값이 존재하는 그래프. 최단 경로를 구할 때 이동 비용 등을 설정할 때 사용하기도 한다.

## 그래프 구현

그래프를 구현하는 방법은 인접 행렬 방식과 인접 리스트 방식이 있다.

- 인접 행렬: 2차원 배열로 정점 간의 간선 여부를 1 또는 0으로 표현하는 방식
- 인접 리스트: 정점을 배열에 저장하고 각 정점에 연결된 정점들을 리스트로 붙이는 방식

파이썬의 경우 연결 리스트 자료구조를 지원하지 않기 때문에 2차원 배열을 연결 리스트처럼 사용하거나 딕셔너리를 활용하여 구현할 수 있다.

```py
# 예시
graph = {
    1: [2, 3] # 1번 노드는 2, 3번 노드와 연결 됐다.
    2: [1, 4] # 2번 노드는 1, 4번 노드와 연결 됐다.
    3: [1] # 3번 노드는 1번 노드와 연결 됐다.
}
```

## 그래프 탐색

선형 자료구조에서 값을 찾을 때는 선형 탐색과 이진 탐색 알고리즘 등을 사용하는 것처럼 그래프를 탐색 할 때는 BFS(너비 우선 탐색), DFS(깊이 우선 탐색) 알고리즘을 사용한다.

## DFS

DFS는 탐색을 시작 지점부터 계속 파고들어 가장 깊은 곳까지 탐색하고 더 이상 탐색할 노드가 없다면 이전 노드로 돌아가서 다음 경로를 탐색한다.
깊이 우선 탐색의 특성상 후입선출 자료구조인 스택을 사용하거나 재귀 함수를 이용하여 구현한다. 다음은 그래프를 만들고 DFS로 그래프를 탐색

DFS는 순회 순서에 따라 다음과 같이 분류할 수 있다.

```py
from collections import deque
N, M = int(input()) # N: 노드 수, M: 간선 수

# 그래프 생성
graph = [[] for _ in range(N + 1)]
for _ in range():
    a, b = map(int , input().split())
    graph[a].append(b)
    graph[b].append(a)

def dfs(start):
    visted[start] = True
    print(start)
    for i in graph[start]:
        if not in i:
            dfs(i)

visted = [False] * (N + 1)
dfs(1)
```

- 전위 순회: 부모 노드 - 왼쪽 노드 - 오른쪽 노드
- 중위 순회: 왼쪽 노드 - 부모 노드 - 오른쪽 노드
- 후위 순회: 왼쪽 노드 - 오른쪽 노드 - 부모 노드

## BFS

BFS는 너비 우선 탐색의 약자로 탐색 시작 지점으로부터 가장 가까운 노드부터 모두 탐색하고 그 다음 노드를 탐색하는 방법이다. BFS의 경우 큐를 활용한다. 다음은 BFS의 과정이다.

1. 탐색을 시작하면 노드를 큐에 넣는다.
2. 큐에서 값을 꺼내고 노드를 확인한다. 나중에 탐색한 노드를 다시 탐색하지 않도록 노드 탐색 여부를 저장한다.
3. 이후 탐색한 노드와 연결된 노드들을 모두 큐에 담는다.
4. 값을 찾거나 모든 그래프를 탐색할 때까지 1-2번을 반복한다.

다음은 그래프를 만들고 BFS로 그래프를 탐색하는 예시 코드이다.

```py
from collections import deque
N, M = int(input()) # N: 노드 수, M: 간선 수

# 그래프 생성
graph = [[] for _ in range(N + 1)]
for _ in range():
    a, b = map(int , input().split())
    graph[a].append(b)
    graph[b].append(a)

def bfs(start):
    queue = deque([start])

    while queue:
        v = queue.popleft()
        print(v)

        for i in graph[v]:
            if not in visted[i]:
                # 노드와 연결된 노드들이 방문한 적이 없다면 큐에 추가
                queue.append(i)
                visted[i] = True

visted = [False] * (N + 1) # 방문한 그래프 저장 용도
bfs(1)
```
